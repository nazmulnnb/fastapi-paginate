{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI Pagination FastAPI Pagination - easy to use pagination for FastAPI. Example of code and generated OpenAPI specification. from fastapi import FastAPI from pydantic import BaseModel from fastapi_paginate import Page , add_pagination , paginate app = FastAPI () class User ( BaseModel ): name : str surname : str users = [ User ( name = 'Yurii' , surname = 'Karabas' ), # ... ] @app . get ( '/users' , response_model = Page [ User ]) async def get_users (): return paginate ( users ) add_pagination ( app ) Available integrations sqlalchemy gino databases ormar orm tortoise To see fully working examples, please visit this link . Installation # Basic version pip install fastapi-paginate # All available integrations pip install fastapi-paginate [ all ]","title":"Home"},{"location":"#fastapi-pagination","text":"FastAPI Pagination - easy to use pagination for FastAPI. Example of code and generated OpenAPI specification. from fastapi import FastAPI from pydantic import BaseModel from fastapi_paginate import Page , add_pagination , paginate app = FastAPI () class User ( BaseModel ): name : str surname : str users = [ User ( name = 'Yurii' , surname = 'Karabas' ), # ... ] @app . get ( '/users' , response_model = Page [ User ]) async def get_users (): return paginate ( users ) add_pagination ( app )","title":"FastAPI Pagination"},{"location":"#available-integrations","text":"sqlalchemy gino databases ormar orm tortoise To see fully working examples, please visit this link .","title":"Available integrations"},{"location":"#installation","text":"# Basic version pip install fastapi-paginate # All available integrations pip install fastapi-paginate [ all ]","title":"Installation"},{"location":"advanced/","text":"There are 3 thing you should know about: Page - pydantic model that represents paginated results. Params - class that represents pagination params passed from user. paginate - function that is used to paginate your query and data. Page and Params fastapi-paginate by default provides you with 2 implementations of Page and Params . 1. Page and Params (default) Params constrains: page >= 0 0 < size <= 100 (default value 50) Data schema of PaginationParams : { \"page\" : 0 , \"size\" : 50 } Data schema of Page : { \"items\" : [ ... ], \"page\" : 0 , \"size\" : 50 , \"total\" : 100 } Can be imported from fastapi-paginate . All integrations with existing libraries are located in fastapi_paginate.ext package. To see fully working integrations usage, please visit this link .","title":"Advanced"},{"location":"advanced/#page-and-params","text":"fastapi-paginate by default provides you with 2 implementations of Page and Params .","title":"Page and Params"},{"location":"advanced/#1-page-and-params-default","text":"Params constrains: page >= 0 0 < size <= 100 (default value 50) Data schema of PaginationParams : { \"page\" : 0 , \"size\" : 50 } Data schema of Page : { \"items\" : [ ... ], \"page\" : 0 , \"size\" : 50 , \"total\" : 100 } Can be imported from fastapi-paginate . All integrations with existing libraries are located in fastapi_paginate.ext package. To see fully working integrations usage, please visit this link .","title":"1. Page and Params (default)"},{"location":"customization/","text":"If you don't like default Page or Params you can always create your own. Page In order to create custom Page you need to inherit from AbstractPage and implement create classmethod. from __future__ import annotations from typing import TypeVar , Generic , Sequence from fastapi_paginate import Params from fastapi_paginate.bases import AbstractPage , AbstractParams T = TypeVar ( \"T\" ) class Page ( AbstractPage [ T ], Generic [ T ]): results : Sequence [ T ] __params_type__ = Params # Set params related to Page @classmethod def create ( cls , items : Sequence [ T ], total : int , params : AbstractParams , ) -> Page [ T ]: return cls ( results = items ) Then it can be used in routes: @app . get ( \"/\" , response_model = Page [ User ]) async def route (): ... JSON:API custom Page example To extend the default Page with additional params, like the JSON:API schema, try the example below: from typing import TypeVar , Generic from fastapi_paginate.links import Page T = TypeVar ( \"T\" ) class JsonApiPage ( Page [ T ], Generic [ T ]): \"\"\"JSON:API 1.0 specification says that result key should be a `data`.\"\"\" class Config : allow_population_by_field_name = True fields = { \"items\" : { \"alias\" : \"data\" }} Params To create a custom Params you should inherit from AbstractParams and implement to_raw_params method. from pydantic import BaseModel from fastapi_paginate.bases import RawParams , AbstractParams class Params ( BaseModel , AbstractParams ): total_items : int return_per_page : int def to_raw_params ( self ) -> RawParams : return RawParams ( limit = self . total_items , offset = self . total_items * self . return_per_page , ) Custom Params values from typing import TypeVar , Generic from fastapi import Query from fastapi_paginate.default import Page as BasePage , Params as BaseParams T = TypeVar ( \"T\" ) class Params ( BaseParams ): size : int = Query ( 500 , ge = 1 , le = 1_000 , description = \"Page size\" ) class Page ( BasePage [ T ], Generic [ T ]): __params_type__ = Params","title":"Customization"},{"location":"customization/#page","text":"In order to create custom Page you need to inherit from AbstractPage and implement create classmethod. from __future__ import annotations from typing import TypeVar , Generic , Sequence from fastapi_paginate import Params from fastapi_paginate.bases import AbstractPage , AbstractParams T = TypeVar ( \"T\" ) class Page ( AbstractPage [ T ], Generic [ T ]): results : Sequence [ T ] __params_type__ = Params # Set params related to Page @classmethod def create ( cls , items : Sequence [ T ], total : int , params : AbstractParams , ) -> Page [ T ]: return cls ( results = items ) Then it can be used in routes: @app . get ( \"/\" , response_model = Page [ User ]) async def route (): ...","title":"Page"},{"location":"customization/#jsonapi-custom-page-example","text":"To extend the default Page with additional params, like the JSON:API schema, try the example below: from typing import TypeVar , Generic from fastapi_paginate.links import Page T = TypeVar ( \"T\" ) class JsonApiPage ( Page [ T ], Generic [ T ]): \"\"\"JSON:API 1.0 specification says that result key should be a `data`.\"\"\" class Config : allow_population_by_field_name = True fields = { \"items\" : { \"alias\" : \"data\" }}","title":"JSON:API custom Page example"},{"location":"customization/#params","text":"To create a custom Params you should inherit from AbstractParams and implement to_raw_params method. from pydantic import BaseModel from fastapi_paginate.bases import RawParams , AbstractParams class Params ( BaseModel , AbstractParams ): total_items : int return_per_page : int def to_raw_params ( self ) -> RawParams : return RawParams ( limit = self . total_items , offset = self . total_items * self . return_per_page , )","title":"Params"},{"location":"customization/#custom-params-values","text":"from typing import TypeVar , Generic from fastapi import Query from fastapi_paginate.default import Page as BasePage , Params as BaseParams T = TypeVar ( \"T\" ) class Params ( BaseParams ): size : int = Query ( 500 , ge = 1 , le = 1_000 , description = \"Page size\" ) class Page ( BasePage [ T ], Generic [ T ]): __params_type__ = Params","title":"Custom Params values"},{"location":"filters-sort/","text":"You can use regular orm statement to paginate the results. So, applying filters are same as you always did. Here is an example for sqlalchemy from fastapi import FastAPI , Depends from pydantic import BaseModel from fastapi_paginate import Page , add_pagination from fastapi_paginate.ext.sqlalchemy import paginate from sqlalchemy.orm import Session app = FastAPI () class UserModel ( Base ): name = Column ( String ) surname = Column ( String ) age = Column ( Integer ) class User ( BaseModel ): name : str surname : str age : int @app . get ( '/users' , response_model = Page [ User ]) async def get_users ( db_session : Session = Depends ( get_db_session )): stmt = db_session . query ( UserModel ) # add filters stmt = stmt . filter ( UserModel . age < 30 ) # sort stmt = stmt . order_by ( asc ( UserModel . age )) return paginate ( stmt ) add_pagination ( app )","title":"Operations"},{"location":"first-steps/","text":"It's pretty easy to use fastapi-paginate . First, you need to import Page , Params and one of paginate functions from fastapi_paginate . Page - is used as response_model in your route declaration. Params - is a user provide params for pagination. paginate - is a function that will paginate your data. from fastapi_paginate import Page , paginate , add_pagination from fastapi import FastAPI from pydantic import BaseModel class User ( BaseModel ): name : str app = FastAPI () users = [ User ( name = \"Yurii\" ), # ... ] @app . get ( \"/\" , response_model = Page [ User ], ) async def route (): return paginate ( users ) add_pagination ( app )","title":"First Steps"}]}